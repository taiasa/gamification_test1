<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çˆ½å¿«ãƒ”ãƒ³ãƒãƒ³ã‚²ãƒ¼ãƒ  ULTIMATE++</title>
    <style>
        :root {
            --primary-color: #0ff;
            --bg-gradient: radial-gradient(circle, #1a1a1a, #000);
        }
        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-gradient);
            color: var(--primary-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas {
            display: block;
            background: #000;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            max-width: 95vw;
            max-height: 80vh;
            border: 2px solid #333;
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px var(--primary-color);
        }
        #score {
            font-size: 32px;
            font-weight: bold;
        }
        #speed-info {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 4px;
        }
        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        .menu-card {
            background: #111;
            padding: 40px;
            border-radius: 15px;
            border: 1px solid var(--primary-color);
        }
        button {
            margin-top: 20px;
            font-size: 20px;
            padding: 12px 30px;
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            cursor: pointer;
            transition: 0.3s;
            border-radius: 5px;
        }
        button:hover {
            background: var(--primary-color);
            color: #000;
        }
        .ruleBox {
            margin: 20px 0;
            text-align: left;
            display: inline-block;
        }
        label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="score">LEFT 0 : 0 RIGHT</div>
    <div id="speed-info">BALL SPEED: x1.00</div>
</div>

<div id="overlay">
    <div class="menu-card">
        <h1>çˆ½å¿«ãƒ”ãƒ³ãƒãƒ³ã‚²ãƒ¼ãƒ </h1>
        <p>
            å·¦ï¼šW / Sï¼ˆA/Dã§ãƒœãƒ¬ãƒ¼ï¼‰<br>
            å³ï¼šâ†‘ / â†“ï¼ˆâ†/â†’ã§ãƒœãƒ¬ãƒ¼ï¼‰<br><br>
            ğŸ”¥ Sï¼šé€Ÿåº¦ | ğŸŒ€ Cï¼šã‚«ãƒ¼ãƒ– | ğŸ“ Lï¼šç›¸æ‰‹å»¶é•· | ğŸŒŸ Uï¼šè¶…å¿…æ®º
        </p>

        <div class="ruleBox">
            <label>
                <input type="radio" name="rule" value="normal" checked> é€šå¸¸ãƒ«ãƒ¼ãƒ«
            </label>
            <label>
                <input type="radio" name="rule" value="volley"> ç‰¹åˆ¥ãƒ«ãƒ¼ãƒ«ï¼ˆå‰å¾Œç§»å‹•ã‚ã‚Šï¼‰
            </label>
        </div>
        <br>
        <button id="startBtn">START GAME</button>
    </div>
</div>

<canvas id="game"></canvas>

<script>
/**
 * Constants & Configuration
 */
const CONFIG = {
    WIDTH: 900,
    HEIGHT: 500,
    WIN_SCORE: 10,
    PADDLE_WIDTH: 12,
    PADDLE_HEIGHT: 100,
    PADDLE_SPEED: 12,
    BALL_RADIUS: 8,
    BALL_INITIAL_VX: 9, // åˆé€Ÿã‚’1.5å€ (6 * 1.5)
    ITEM_SPAWN_RATE: 3500,
    BOUNCE_SPEED_UP_STEP: 5,
    ITEM_RADIUS: 24, // ã‚¢ã‚¤ãƒ†ãƒ ã‚µã‚¤ã‚ºã‚’å¤§ãã
    COLORS: {
        PADDLE: "#0ff",
        BALL: "#fff",
        SPEED: "#f33",
        CURVE: "#3f3",
        LONG: "#ff3",
        ULTIMATE: "#f0f"
    }
};

/**
 * Audio Manager
 */
const AudioMgr = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },
    play(freq, duration = 0.1, type = "sine", volume = 0.2) {
        if (!this.ctx || this.ctx.state === 'suspended') return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, this.ctx.currentTime);
        g.gain.setValueAtTime(volume, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
        o.connect(g).connect(this.ctx.destination);
        o.start();
        o.stop(this.ctx.currentTime + duration);
    },
    seHit() { this.play(900, 0.05, "square", 0.1); },
    seScore() { this.play(220, 0.4, "sawtooth", 0.2); },
    seItem() { this.play(1200, 0.2, "triangle", 0.15); },
    seUltimate() { 
        this.play(600, 0.5, "sawtooth", 0.2);
        this.play(800, 0.5, "sine", 0.2);
    },
    seCount(freq) { this.play(freq, 0.1, "sine", 0.1); }
};

/**
 * Game State
 */
const state = {
    running: false,
    gameOver: false,
    rule: "normal",
    scoreL: 0,
    scoreR: 0,
    paddles: {
        left: { x: 30, y: 250, tx: 30, ty: 250, h: CONFIG.PADDLE_HEIGHT },
        right: { x: 858, y: 250, tx: 858, ty: 250, h: CONFIG.PADDLE_HEIGHT }
    },
    ball: { 
        x: 450, y: 250, vx: 0, vy: 0, speed: 1, baseSpeedMult: 1, bounceCount: 0,
        isUltimate: false, ultimateTime: 0
    },
    items: [],
    curve: { delay: 0, power: 0 },
    keys: new Set(),
    lastItemSpawn: 0,
    countdown: 0,
    frameCounter: 0
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = CONFIG.WIDTH;
canvas.height = CONFIG.HEIGHT;

/**
 * Core Functions
 */
function resetBall(dir = 1) {
    state.ball = {
        x: CONFIG.WIDTH / 2,
        y: CONFIG.HEIGHT / 2,
        vx: dir * CONFIG.BALL_INITIAL_VX,
        vy: (Math.random() * 2 - 1) * 4,
        speed: 1,
        baseSpeedMult: 1,
        bounceCount: 0,
        isUltimate: false,
        ultimateTime: 0
    };
    state.curve = { delay: 0, power: 0 };
    startCountdown();
}

function startCountdown() {
    state.countdown = 3;
    const timer = setInterval(() => {
        state.countdown--;
        if (state.countdown > 0) {
            AudioMgr.seCount(440);
        } else {
            AudioMgr.seCount(880);
            clearInterval(timer);
        }
    }, 700);
}

function updateScoreUI() {
    document.getElementById("score").textContent = `LEFT ${state.scoreL} : ${state.scoreR} RIGHT`;
}

function updateSpeedUI() {
    const totalSpeed = (state.ball.speed * state.ball.baseSpeedMult).toFixed(2);
    document.getElementById("speed-info").textContent = `BALL SPEED: x${totalSpeed} ${state.ball.isUltimate ? '!!ULTIMATE!!' : ''}`;
}

function applyItem(type, isLeftCollector) {
    if (type === "ultimate") {
        AudioMgr.seUltimate();
        state.ball.isUltimate = true;
        state.ball.ultimateTime = 180; // ç´„3ç§’
    } else {
        AudioMgr.seItem();
        if (type === "speed") state.ball.speed += 0.5;
        if (type === "curve") {
            state.curve.delay = 30;
            state.curve.power = (Math.random() > 0.5 ? 1 : -1) * (5 + Math.random() * 5);
        }
        if (type === "long") {
            const target = isLeftCollector ? state.paddles.right : state.paddles.left;
            target.h = 160;
            setTimeout(() => target.h = CONFIG.PADDLE_HEIGHT, 5000);
        }
    }
    updateSpeedUI();
}

/**
 * Game Loop - Update
 */
function update() {
    if (!state.running || state.gameOver) return;
    state.frameCounter++;

    const { paddles, keys, ball } = state;

    // Paddle Movement
    if (keys.has("KeyW")) paddles.left.ty -= CONFIG.PADDLE_SPEED;
    if (keys.has("KeyS")) paddles.left.ty += CONFIG.PADDLE_SPEED;
    if (keys.has("ArrowUp")) paddles.right.ty -= CONFIG.PADDLE_SPEED;
    if (keys.has("ArrowDown")) paddles.right.ty += CONFIG.PADDLE_SPEED;

    if (state.rule === "volley") {
        if (keys.has("KeyA")) paddles.left.tx -= 8;
        if (keys.has("KeyD")) paddles.left.tx += 8;
        if (keys.has("ArrowLeft")) paddles.right.tx -= 8;
        if (keys.has("ArrowRight")) paddles.right.tx += 8;
    }

    for (let side in paddles) {
        const p = paddles[side];
        p.ty = Math.max(p.h / 2, Math.min(CONFIG.HEIGHT - p.h / 2, p.ty));
        p.x += (p.tx - p.x) * 0.25;
        p.y += (p.ty - p.y) * 0.25;
    }

    if (state.countdown > 0) return;

    // Ball Physics
    const currentSpeed = ball.speed * ball.baseSpeedMult;
    let moveX = ball.vx * currentSpeed;
    let moveY = ball.vy * currentSpeed;

    // è¶…å¿…æ®ºæŠ€ï¼šãã‚‹ãã‚‹å›è»¢è»Œé“
    if (ball.isUltimate) {
        ball.ultimateTime--;
        const swirlScale = 15;
        moveY += Math.sin(state.frameCounter * 0.2) * swirlScale;
        if (ball.ultimateTime <= 0) ball.isUltimate = false;
    }

    ball.x += moveX;
    ball.y += moveY;

    if (state.curve.delay > 0) {
        state.curve.delay--;
        if (state.curve.delay === 0) ball.vy += state.curve.power;
    }

    // Wall Bounce
    if (ball.y < CONFIG.BALL_RADIUS || ball.y > CONFIG.HEIGHT - CONFIG.BALL_RADIUS) {
        ball.vy *= -1;
        ball.y = ball.y < CONFIG.BALL_RADIUS ? CONFIG.BALL_RADIUS : CONFIG.HEIGHT - CONFIG.BALL_RADIUS;
        handleBounce();
    }

    // Paddle Hits
    const checkPaddleHit = (p, isLeft) => {
        if (ball.x + CONFIG.BALL_RADIUS > p.x && 
            ball.x - CONFIG.BALL_RADIUS < p.x + CONFIG.PADDLE_WIDTH &&
            ball.y > p.y - p.h / 2 && ball.y < p.y + p.h / 2) {
            
            AudioMgr.seHit();
            const relativeIntersectY = (ball.y - p.y) / (p.h / 2);
            ball.vy = relativeIntersectY * 7;
            ball.vx = isLeft ? Math.abs(ball.vx) : -Math.abs(ball.vx);
            ball.x = isLeft ? p.x + CONFIG.PADDLE_WIDTH + CONFIG.BALL_RADIUS : p.x - CONFIG.BALL_RADIUS;
            
            // ãƒ’ãƒƒãƒˆæ™‚ã«å¿…æ®ºæŠ€ãŒåˆ‡ã‚Œã‚‹
            if (ball.isUltimate) ball.isUltimate = false;
            handleBounce();
        }
    };
    checkPaddleHit(paddles.left, true);
    checkPaddleHit(paddles.right, false);

    function handleBounce() {
        ball.bounceCount++;
        if (ball.bounceCount >= CONFIG.BOUNCE_SPEED_UP_STEP) {
            ball.bounceCount = 0;
            ball.baseSpeedMult += 0.1;
            updateSpeedUI();
        }
    }

    // Items Logic
    const now = Date.now();
    if (now - state.lastItemSpawn > CONFIG.ITEM_SPAWN_RATE && state.items.length < 4) {
        const rand = Math.random();
        let type = "speed";
        if (rand < 0.1) type = "ultimate"; // 10%ã§è¶…å¿…æ®º
        else if (rand < 0.4) type = "curve";
        else if (rand < 0.7) type = "long";

        state.items.push({
            x: 200 + Math.random() * (CONFIG.WIDTH - 400),
            y: 80 + Math.random() * (CONFIG.HEIGHT - 160),
            r: CONFIG.ITEM_RADIUS,
            type: type,
            pulse: 0
        });
        state.lastItemSpawn = now;
    }

    state.items = state.items.filter(it => {
        const dist = Math.hypot(ball.x - it.x, ball.y - it.y);
        if (dist < CONFIG.BALL_RADIUS + it.r) {
            applyItem(it.type, ball.vx < 0);
            return false;
        }
        return true;
    });

    if (ball.x < 0) { state.scoreR++; handleScore(); }
    else if (ball.x > CONFIG.WIDTH) { state.scoreL++; handleScore(); }
}

/**
 * Game Loop - Draw
 */
function draw() {
    ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

    // Center Line
    ctx.setLineDash([10, 10]);
    ctx.strokeStyle = "#222";
    ctx.beginPath(); ctx.moveTo(CONFIG.WIDTH / 2, 0); ctx.lineTo(CONFIG.WIDTH / 2, CONFIG.HEIGHT); ctx.stroke();
    ctx.setLineDash([]);

    // Items
    state.items.forEach(it => {
        const color = CONFIG.COLORS[it.type.toUpperCase()];
        it.pulse = (it.pulse + 0.1) % (Math.PI * 2);
        const s = it.r + Math.sin(it.pulse) * 4;

        // Glow
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        
        // Outer circle
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(it.x, it.y, s, 0, Math.PI * 2); ctx.stroke();
        
        // Inner circle
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath(); ctx.arc(it.x, it.y, it.r - 2, 0, Math.PI * 2); ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Icon Text/Emoji
        const icons = { speed: "ğŸ”¥", curve: "ğŸŒ€", long: "ğŸ“", ultimate: "ğŸŒŸ" };
        ctx.font = "24px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(icons[it.type], it.x, it.y);
    });

    // Paddles
    ctx.fillStyle = CONFIG.COLORS.PADDLE;
    ctx.shadowBlur = 10;
    ctx.shadowColor = CONFIG.COLORS.PADDLE;
    ctx.fillRect(state.paddles.left.x, state.paddles.left.y - state.paddles.left.h / 2, CONFIG.PADDLE_WIDTH, state.paddles.left.h);
    ctx.fillRect(state.paddles.right.x, state.paddles.right.y - state.paddles.right.h / 2, CONFIG.PADDLE_WIDTH, state.paddles.right.h);
    ctx.shadowBlur = 0;

    // Ball
    if (state.ball.isUltimate) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = CONFIG.COLORS.ULTIMATE;
        ctx.fillStyle = CONFIG.COLORS.ULTIMATE;
    } else {
        ctx.fillStyle = CONFIG.COLORS.BALL;
    }
    ctx.beginPath();
    ctx.arc(state.ball.x, state.ball.y, CONFIG.BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // UI Layer
    if (state.countdown > 0) {
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.fillRect(0,0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.font = "bold 120px sans-serif";
        ctx.fillStyle = state.countdown === 3 ? "#f33" : state.countdown === 2 ? "#ff3" : "#3f3";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(state.countdown, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
    }

    if (state.gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.fillRect(0,0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.font = "bold 64px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(state.scoreL > state.scoreR ? "LEFT WIN!!" : "RIGHT WIN!!", CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
    }
}

function handleScore() {
    AudioMgr.seScore();
    updateScoreUI();
    state.items = [];
    if (state.scoreL >= CONFIG.WIN_SCORE || state.scoreR >= CONFIG.WIN_SCORE) {
        state.gameOver = true;
        setTimeout(() => location.reload(), 5000);
    } else {
        resetBall(state.scoreL > state.scoreR ? 1 : -1);
        updateSpeedUI();
    }
}

function initGame() {
    AudioMgr.init();
    state.rule = document.querySelector("input[name=rule]:checked").value;
    state.scoreL = 0; state.scoreR = 0; state.items = [];
    state.running = true; state.gameOver = false;
    state.lastItemSpawn = Date.now();
    updateScoreUI(); resetBall(Math.random() > 0.5 ? 1 : -1); updateSpeedUI();
    document.getElementById("overlay").style.display = "none";
}

document.getElementById("startBtn").addEventListener("click", initGame);
window.addEventListener("keydown", e => state.keys.add(e.code));
window.addEventListener("keyup", e => state.keys.delete(e.code));

(function loop() {
    update(); draw();
    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
