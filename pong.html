<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çˆ½å¿«ãƒ”ãƒ³ãƒãƒ³ã‚²ãƒ¼ãƒ  ULTIMATE++</title>
    <style>
        :root {
            --primary-color: #0ff;
            --bg-gradient: radial-gradient(circle, #1a1a1a, #000);
        }
        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-gradient);
            color: var(--primary-color);
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }
        canvas {
            display: block;
            background: #000;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.2);
            max-width: 95vw;
            max-height: 80vh;
            border: 2px solid #333;
        }
        #ui {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px var(--primary-color);
        }
        #score {
            font-size: 32px;
            font-weight: bold;
        }
        #speed-info {
            font-size: 14px;
            opacity: 0.8;
            margin-top: 4px;
        }
        #overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            z-index: 10;
        }
        .menu-card {
            background: #111;
            padding: 40px;
            border-radius: 15px;
            border: 1px solid var(--primary-color);
        }
        button {
            margin-top: 20px;
            font-size: 20px;
            padding: 12px 30px;
            background: transparent;
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            cursor: pointer;
            transition: 0.3s;
            border-radius: 5px;
        }
        button:hover {
            background: var(--primary-color);
            color: #000;
        }
        .ruleBox {
            margin: 20px 0;
            text-align: left;
            display: inline-block;
        }
        label {
            display: block;
            margin: 10px 0;
            cursor: pointer;
        }
    </style>
</head>
<body>

<div id="ui">
    <div id="score">LEFT 0 : 0 RIGHT</div>
    <div id="speed-info">BALL SPEED: x1.00</div>
</div>

<div id="overlay">
    <div class="menu-card">
        <h1>çˆ½å¿«ãƒ”ãƒ³ãƒãƒ³ã‚²ãƒ¼ãƒ </h1>
        <p>
            å·¦ï¼šW / Sï¼ˆA/Dã§ãƒœãƒ¬ãƒ¼ï¼‰<br>
            å³ï¼šâ†‘ / â†“ï¼ˆâ†/â†’ã§ãƒœãƒ¬ãƒ¼ï¼‰<br><br>
            ğŸ”¥ Sï¼šé€Ÿåº¦UP | ğŸŒ€ Cï¼šæ€¥ã‚«ãƒ¼ãƒ– | ğŸ“ Lï¼šç›¸æ‰‹å»¶é•·
        </p>

        <div class="ruleBox">
            <label>
                <input type="radio" name="rule" value="normal" checked> é€šå¸¸ãƒ«ãƒ¼ãƒ«
            </label>
            <label>
                <input type="radio" name="rule" value="volley"> ç‰¹åˆ¥ãƒ«ãƒ¼ãƒ«ï¼ˆå‰å¾Œç§»å‹•ã‚ã‚Šï¼‰
            </label>
        </div>
        <br>
        <button id="startBtn">START GAME</button>
    </div>
</div>

<canvas id="game"></canvas>

<script>
/**
 * Constants & Configuration
 */
const CONFIG = {
    WIDTH: 900,
    HEIGHT: 500,
    WIN_SCORE: 10,
    PADDLE_WIDTH: 12,
    PADDLE_HEIGHT: 100,
    PADDLE_SPEED: 12, // ã‚¹ãƒ”ãƒ¼ãƒ‰ã‚¢ãƒƒãƒ—
    BALL_RADIUS: 8,
    BALL_INITIAL_VX: 6,
    ITEM_SPAWN_RATE: 4000,
    BOUNCE_SPEED_UP_STEP: 5, // 5å›ã”ã¨ã«åŠ é€Ÿ
    COLORS: {
        PADDLE: "#0ff",
        BALL: "#fff",
        SPEED: "#f33",
        CURVE: "#3f3",
        LONG: "#ff3"
    }
};

/**
 * Audio Manager
 */
const AudioMgr = {
    ctx: null,
    init() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    },
    play(freq, duration = 0.1, type = "sine", volume = 0.2) {
        if (!this.ctx || this.ctx.state === 'suspended') return;
        const o = this.ctx.createOscillator();
        const g = this.ctx.createGain();
        o.type = type;
        o.frequency.setValueAtTime(freq, this.ctx.currentTime);
        g.gain.setValueAtTime(volume, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.0001, this.ctx.currentTime + duration);
        o.connect(g).connect(this.ctx.destination);
        o.start();
        o.stop(this.ctx.currentTime + duration);
    },
    seHit() { this.play(900, 0.05, "square", 0.1); },
    seScore() { this.play(220, 0.4, "sawtooth", 0.2); },
    seItem() { this.play(1200, 0.15, "triangle", 0.15); },
    seCount(freq) { this.play(freq, 0.1, "sine", 0.1); }
};

/**
 * Game State
 */
const state = {
    running: false,
    gameOver: false,
    rule: "normal",
    scoreL: 0,
    scoreR: 0,
    paddles: {
        left: { x: 30, y: 250, tx: 30, ty: 250, h: CONFIG.PADDLE_HEIGHT },
        right: { x: 858, y: 250, tx: 858, ty: 250, h: CONFIG.PADDLE_HEIGHT }
    },
    ball: { x: 450, y: 250, vx: 0, vy: 0, speed: 1, baseSpeedMult: 1, bounceCount: 0 },
    items: [],
    curve: { delay: 0, power: 0 },
    keys: new Set(),
    lastItemSpawn: 0,
    countdown: 0 // ã‚«ã‚¦ãƒ³ãƒˆãƒ€ã‚¦ãƒ³ç§’æ•°
};

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = CONFIG.WIDTH;
canvas.height = CONFIG.HEIGHT;

/**
 * Core Functions
 */
function resetBall(dir = 1) {
    state.ball = {
        x: CONFIG.WIDTH / 2,
        y: CONFIG.HEIGHT / 2,
        vx: dir * CONFIG.BALL_INITIAL_VX,
        vy: (Math.random() * 2 - 1) * 4,
        speed: 1,
        baseSpeedMult: 1, // è·³ã­è¿”ã‚Šã«ã‚ˆã‚‹åŠ é€Ÿå€ç‡
        bounceCount: 0
    };
    state.curve = { delay: 0, power: 0 };
    startCountdown();
}

function startCountdown() {
    state.countdown = 3; // 3, 2, 1
    const timer = setInterval(() => {
        state.countdown--;
        if (state.countdown > 0) {
            AudioMgr.seCount(440);
        } else {
            AudioMgr.seCount(880);
            clearInterval(timer);
        }
    }, 700);
}

function updateScoreUI() {
    document.getElementById("score").textContent = `LEFT ${state.scoreL} : ${state.scoreR} RIGHT`;
}

function updateSpeedUI() {
    const totalSpeed = (state.ball.speed * state.ball.baseSpeedMult).toFixed(2);
    document.getElementById("speed-info").textContent = `BALL SPEED: x${totalSpeed}`;
}

function applyItem(type, isLeftCollector) {
    AudioMgr.seItem();
    if (type === "speed") state.ball.speed += 0.5;
    if (type === "curve") {
        state.curve.delay = 40;
        state.curve.power = (Math.random() > 0.5 ? 1 : -1) * (4 + Math.random() * 3);
    }
    if (type === "long") {
        const target = isLeftCollector ? state.paddles.right : state.paddles.left;
        target.h = 160;
        setTimeout(() => target.h = CONFIG.PADDLE_HEIGHT, 5000);
    }
    updateSpeedUI();
}

/**
 * Game Loop - Update
 */
function update() {
    if (!state.running || state.gameOver) return;

    const { paddles, keys, ball } = state;

    // Paddle Movement (Always enabled even during countdown)
    if (keys.has("KeyW")) paddles.left.ty -= CONFIG.PADDLE_SPEED;
    if (keys.has("KeyS")) paddles.left.ty += CONFIG.PADDLE_SPEED;
    if (keys.has("ArrowUp")) paddles.right.ty -= CONFIG.PADDLE_SPEED;
    if (keys.has("ArrowDown")) paddles.right.ty += CONFIG.PADDLE_SPEED;

    if (state.rule === "volley") {
        if (keys.has("KeyA")) paddles.left.tx -= 8;
        if (keys.has("KeyD")) paddles.left.tx += 8;
        if (keys.has("ArrowLeft")) paddles.right.tx -= 8;
        if (keys.has("ArrowRight")) paddles.right.tx += 8;
    }

    // Constraints
    paddles.left.tx = Math.max(10, Math.min(CONFIG.WIDTH / 2 - 40, paddles.left.tx));
    paddles.right.tx = Math.max(CONFIG.WIDTH / 2 + 20, Math.min(CONFIG.WIDTH - 30, paddles.right.tx));
    
    for (let side in paddles) {
        const p = paddles[side];
        p.ty = Math.max(p.h / 2, Math.min(CONFIG.HEIGHT - p.h / 2, p.ty));
        p.x += (p.tx - p.x) * 0.25;
        p.y += (p.ty - p.y) * 0.25;
    }

    // Ball & Items (Paused during countdown)
    if (state.countdown > 0) return;

    // Ball Physics
    const currentSpeed = ball.speed * ball.baseSpeedMult;
    ball.x += ball.vx * currentSpeed;
    ball.y += ball.vy * currentSpeed;

    if (state.curve.delay > 0) {
        state.curve.delay--;
        if (state.curve.delay === 0) ball.vy += state.curve.power;
    }

    // Wall Bounce
    if (ball.y < CONFIG.BALL_RADIUS || ball.y > CONFIG.HEIGHT - CONFIG.BALL_RADIUS) {
        ball.vy *= -1;
        ball.y = ball.y < CONFIG.BALL_RADIUS ? CONFIG.BALL_RADIUS : CONFIG.HEIGHT - CONFIG.BALL_RADIUS;
        handleBounce();
    }

    // Collision Detection
    const checkPaddleHit = (p, isLeft) => {
        if (ball.x + CONFIG.BALL_RADIUS > p.x && 
            ball.x - CONFIG.BALL_RADIUS < p.x + CONFIG.PADDLE_WIDTH &&
            ball.y > p.y - p.h / 2 && ball.y < p.y + p.h / 2) {
            
            AudioMgr.seHit();
            const relativeIntersectY = (ball.y - p.y) / (p.h / 2);
            ball.vy = relativeIntersectY * 7;
            ball.vx = isLeft ? Math.abs(ball.vx) : -Math.abs(ball.vx);
            ball.x = isLeft ? p.x + CONFIG.PADDLE_WIDTH + CONFIG.BALL_RADIUS : p.x - CONFIG.BALL_RADIUS;
            handleBounce();
        }
    };
    checkPaddleHit(paddles.left, true);
    checkPaddleHit(paddles.right, false);

    function handleBounce() {
        ball.bounceCount++;
        if (ball.bounceCount >= CONFIG.BOUNCE_SPEED_UP_STEP) {
            ball.bounceCount = 0;
            ball.baseSpeedMult += 0.1;
            updateSpeedUI();
        }
    }

    // Items Logic
    const now = Date.now();
    if (now - state.lastItemSpawn > CONFIG.ITEM_SPAWN_RATE && state.items.length < 5) {
        state.items.push({
            x: 150 + Math.random() * (CONFIG.WIDTH - 300),
            y: 50 + Math.random() * (CONFIG.HEIGHT - 100),
            r: 18,
            type: ["speed", "curve", "long"][Math.floor(Math.random() * 3)]
        });
        state.lastItemSpawn = now;
    }

    state.items = state.items.filter(it => {
        const dist = Math.hypot(ball.x - it.x, ball.y - it.y);
        if (dist < CONFIG.BALL_RADIUS + it.r) {
            applyItem(it.type, ball.vx < 0);
            return false;
        }
        return true;
    });

    // Scoring
    if (ball.x < 0) { state.scoreR++; handleScore(); }
    else if (ball.x > CONFIG.WIDTH) { state.scoreL++; handleScore(); }
}

function handleScore() {
    AudioMgr.seScore();
    updateScoreUI();
    state.items = [];
    if (state.scoreL >= CONFIG.WIN_SCORE || state.scoreR >= CONFIG.WIN_SCORE) {
        state.gameOver = true;
        setTimeout(() => location.reload(), 5000);
    } else {
        resetBall(state.scoreL > state.scoreR ? 1 : -1);
        updateSpeedUI();
    }
}

/**
 * Game Loop - Draw
 */
function draw() {
    ctx.clearRect(0, 0, CONFIG.WIDTH, CONFIG.HEIGHT);

    // Center Line
    ctx.setLineDash([10, 10]);
    ctx.strokeStyle = "#333";
    ctx.beginPath();
    ctx.moveTo(CONFIG.WIDTH / 2, 0);
    ctx.lineTo(CONFIG.WIDTH / 2, CONFIG.HEIGHT);
    ctx.stroke();
    ctx.setLineDash([]);

    // Paddles
    ctx.fillStyle = CONFIG.COLORS.PADDLE;
    ctx.fillRect(state.paddles.left.x, state.paddles.left.y - state.paddles.left.h / 2, CONFIG.PADDLE_WIDTH, state.paddles.left.h);
    ctx.fillRect(state.paddles.right.x, state.paddles.right.y - state.paddles.right.h / 2, CONFIG.PADDLE_WIDTH, state.paddles.right.h);

    // Ball
    ctx.fillStyle = CONFIG.COLORS.BALL;
    ctx.beginPath();
    ctx.arc(state.ball.x, state.ball.y, CONFIG.BALL_RADIUS, 0, Math.PI * 2);
    ctx.fill();

    // Items
    state.items.forEach(it => {
        ctx.fillStyle = CONFIG.COLORS[it.type.toUpperCase()];
        ctx.beginPath();
        ctx.arc(it.x, it.y, it.r, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#000";
        ctx.font = "bold 16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(it.type[0].toUpperCase(), it.x, it.y);
    });

    // Countdown UI
    if (state.countdown > 0) {
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(0,0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.font = "bold 120px sans-serif";
        ctx.fillStyle = varColor();
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(state.countdown, CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
    }

    function varColor() {
        return state.countdown === 3 ? "#f33" : state.countdown === 2 ? "#ff3" : "#3f3";
    }

    if (state.gameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.7)";
        ctx.fillRect(0,0, CONFIG.WIDTH, CONFIG.HEIGHT);
        ctx.font = "bold 64px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.textAlign = "center";
        ctx.fillText(state.scoreL > state.scoreR ? "LEFT WIN!!" : "RIGHT WIN!!", CONFIG.WIDTH / 2, CONFIG.HEIGHT / 2);
    }
}

/**
 * Initialization & Events
 */
function initGame() {
    AudioMgr.init();
    state.rule = document.querySelector("input[name=rule]:checked").value;
    state.scoreL = 0;
    state.scoreR = 0;
    state.items = [];
    state.running = true;
    state.gameOver = false;
    state.lastItemSpawn = Date.now();
    updateScoreUI();
    resetBall(Math.random() > 0.5 ? 1 : -1);
    updateSpeedUI();
    document.getElementById("overlay").style.display = "none";
}

document.getElementById("startBtn").addEventListener("click", initGame);

window.addEventListener("keydown", e => state.keys.add(e.code));
window.addEventListener("keyup", e => state.keys.delete(e.code));

function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

</script>
</body>
</html>
