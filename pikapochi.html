<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ピカッとポチッと</title>
    <style>
        :root {
            --bg-color-1: #0f0c29;
            --bg-color-2: #302b63;
            --bg-color-3: #24243e;
            --accent: #00d2ff;
            --accent-glow: #00c6ff;
            --text: #ffffff;
            --perfect: #ff00de;
            --great: #00ffaa;
            --good: #ffcc00;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, var(--bg-color-1), var(--bg-color-2), var(--bg-color-3));
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text);
            user-select: none;
        }

        /* UI Overlays */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
        }

        .screen {
            display: none;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.75);
            padding: 40px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: fadeIn 0.5s ease;
            max-width: 600px;
            width: 90%;
            transition: all 0.3s ease;
        }

        .screen.active {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* Prep Screen Specific: Shift up to clear bottom guides */
        #prep-screen {
            transform: translateY(-100px); /* Move up */
        }
        #prep-screen.active {
            transform: translateY(-80px); /* Maintain offset when active */
        }

        /* Slot Machine Display */
        #slot-screen {
            background: transparent;
            box-shadow: none;
            border: none;
            backdrop-filter: none;
        }
        .slot-container {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 20px var(--accent);
            margin-bottom: 20px;
        }
        .slot-label {
            font-size: 1.5rem;
            color: #aaa;
            margin-bottom: 10px;
            display: block;
        }
        .slot-value {
            display: block;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 10px 40px;
            border-radius: 10px;
            border: 2px solid var(--accent);
            min-width: 300px;
        }
        .slot-key {
            font-size: 5rem;
            color: var(--accent);
            display: block;
            margin-top: 10px;
        }

        h1 {
            font-size: 3rem;
            margin: 0 0 20px 0;
            text-shadow: 0 0 15px var(--accent);
            letter-spacing: 2px;
        }

        h2 {
            font-size: 2rem;
            margin: 10px 0;
            color: var(--accent);
        }

        p {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 25px;
            color: #ddd;
        }

        .btn {
            background: linear-gradient(45deg, #00d2ff, #3a7bd5);
            border: none;
            padding: 15px 40px;
            font-size: 1.4rem;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s;
            margin: 10px;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(0, 210, 255, 0.4);
            text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }

        .btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 210, 255, 0.6);
        }

        .btn.secondary {
            background: transparent;
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: none;
        }
        .btn.secondary:hover {
            background: rgba(255,255,255,0.1);
            border-color: #fff;
        }

        .player-select {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        .select-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            padding: 12px 24px;
            border-radius: 12px;
            color: #aaa;
            cursor: pointer;
            font-size: 1.1rem;
            transition: all 0.2s;
        }

        .select-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .select-btn.selected {
            border-color: var(--accent);
            background: rgba(0, 210, 255, 0.15);
            color: #fff;
            box-shadow: 0 0 15px rgba(0, 210, 255, 0.3);
            transform: scale(1.05);
        }

        #prep-timer {
            font-size: 4rem;
            font-weight: bold;
            color: var(--accent);
            text-shadow: 0 0 20px var(--accent);
            margin: 10px 0;
        }

        #countdown-display {
            font-size: 10rem;
            font-weight: bold;
            text-shadow: 0 0 30px white;
            animation: pulse 1s infinite;
        }

        /* Leaderboard */
        .leaderboard {
            width: 100%;
            margin: 20px 0;
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 10px;
        }
        .rank-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 15px;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            font-size: 1.1rem;
        }
        .rank-row:last-child { border-bottom: none; }
        .rank-num { font-weight: bold; color: var(--accent); width: 30px;}
        .rank-score { font-weight: bold; }
        .rank-names { font-size: 0.9rem; color: #aaa; text-align: right; flex: 1; margin-right: 15px;}

        /* In-Game UI */
        #game-hud {
            position: absolute;
            top: 20px;
            width: 90%;
            display: flex;
            justify-content: space-between;
            font-size: 1.8rem;
            font-weight: bold;
            pointer-events: none;
            z-index: 5;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #timer-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 12px;
            background: linear-gradient(90deg, var(--accent), #fff);
            width: 100%;
            box-shadow: 0 0 20px var(--accent);
            transition: width 0.1s linear;
        }

        #key-guides {
            position: absolute;
            bottom: 30px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 15px;
            pointer-events: none;
            flex-wrap: wrap;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 20; /* Ensure visible */
        }

        .key-guide-item {
            background: rgba(0, 0, 0, 0.7);
            padding: 12px 20px;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            font-size: 1.1rem;
            color: #fff;
            backdrop-filter: blur(5px);
            text-align: center;
            min-width: 110px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        /* New Element popping in */
        .key-guide-item.pop-in {
            animation: popIn 0.5s forwards;
        }

        .key-guide-key {
            font-weight: 800;
            font-size: 2rem;
            display: block;
            margin-bottom: 5px;
            text-shadow: 0 0 10px currentColor;
        }

        .key-guide-name {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        @keyframes popIn {
            0% { opacity: 0; transform: scale(0.5) translateY(20px); }
            100% { opacity: 1; transform: scale(1) translateY(0); }
        }
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        canvas { display: block; }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <!-- Start Screen -->
        <div id="start-screen" class="screen active">
            <h1>ピカッとポチッと</h1>
            <p>仲間と協力してハイスコアを目指せ！<br>
            光ったらキーを押すシンプルゲーム。<br>
            2人同時に光ったら、息を合わせて<b>同時押し！</b></p>
            <p>「スタート」の前に順番を決めてね</P>
            
            <div class="player-select">
                <button class="select-btn selected" onclick="setPlayerCount(2)">2人</button>
                <button class="select-btn" onclick="setPlayerCount(3)">3人</button>
                <button class="select-btn" onclick="setPlayerCount(4)">4人</button>
                <button class="select-btn" onclick="setPlayerCount(5)">5人</button>
            </div>
            
            <button class="btn" onclick="game.startSlotSequence()">スタート！</button>
        </div>

        <!-- Slot Machine Screen -->
        <div id="slot-screen" class="screen">
            <div class="slot-container">
                <span class="slot-label" id="slot-player-label">Player 1</span>
                <span class="slot-value" id="slot-name">???</span>
                <span class="slot-key" id="slot-key">?</span>
            </div>
        </div>

        <!-- Prep Screen -->
        <div id="prep-screen" class="screen">
            <h2>担当を確認してね！</h2>
            <p>画面下のガイドがあなたのニックネームとキーです。<br>キーの位置を確認しよう！</p>
            <div id="prep-timer">30</div>
            <button class="btn" onclick="game.skipPrep()">始めちゃう！</button>
        </div>

        <!-- Countdown -->
        <div id="countdown-screen" class="screen" style="background:none; border:none; box-shadow:none; backdrop-filter:none;">
            <div id="countdown-display">3</div>
        </div>

        <!-- Result Screen -->
        <div id="result-screen" class="screen">
            <h1>FINISH!</h1>
            <h2 id="result-score" style="font-size:3rem; margin:10px 0;">0</h2>
            <p id="result-comment">ナイスチームワーク！</p>
            
            <div class="leaderboard" id="leaderboard">
                <!-- Rank rows inserted by JS -->
            </div>

            <div style="display:flex; flex-wrap:wrap; justify-content:center;">
                <button class="btn" onclick="game.startSlotSequence()">もう一度プレーする？</button>
                <button class="btn secondary" onclick="game.returnToTitle()">スタート画面に戻る</button>
            </div>
        </div>
    </div>

    <!-- HUD -->
    <div id="game-hud" style="display:none;">
        <div id="score-display">Score: 0</div>
        <div id="time-display">Time: 30</div>
    </div>
    <div id="key-guides" style="display:flex;"></div>
    <div id="timer-bar" style="display:none;"></div>

<script>
/**
 * 定数・設定
 */
const CONSTANTS = {
    GAME_DURATION: 30,
    PREP_DURATION: 30,
    BASE_SPAWN_RATE: 1800, 
    MIN_SPAWN_RATE: 500,
    RESONANCE_CHANCE: 0.4,
    RESONANCE_WINDOW_1: 150, // Perfect
    RESONANCE_WINDOW_2: 500, // Great
    RESONANCE_WINDOW_3: 1000, // Good
    TARGET_DURATION: 1600,
    COLORS: ['#FF0055', '#00FF55', '#00D2FF', '#FFD700', '#FF00FF']
};

const WORDS = {
    adjectives: ['おどる', 'もふもふ', 'きらきら', 'さすらいの', 'ねむれる', 'あわてんぼう', '輝く', '爆速の', '腹ペコの', 
    '夢見る', '天才', 'のんびり', '勇者', '伝説の',"ふわふわ","どや顔の","ひみつの","うっかり","超元気な","ころころ","渋い",
    "にやにや","ドジな","最強の","ミラクルな","ぷるぷる","怪しい","ごきげんな","孤高の","半笑いの","やたら声でかい","空気読まない",
    "すぐ調子乗る","意味なく全力の","なぜか上から目線の","テンション迷子の","無駄にキレッキレな","だいたい寝不足の","謎に自信満々な",
    "ちょっと滑ってる","全然反省しない","急に真顔になる","ボケ倒す","ツッコミ待ちの","だいたい遅刻する","静かに狂ってる",
    "方向性を見失った","急に哲学する","無限にしゃべる","無駄に丁寧な","急に距離詰める","やけに事情通な","根拠ゼロの","なぜか謝りがちな",
    "勝手に感動してる","微妙に勘違いしてる","話が長い","記憶があいまいな","テンポだけ良い","勢いで生きてる","妙にリアルな","方向音痴な",
    "一周まわって普通の","やたら間を取る","急に例え話する","顔だけ本気の","気配だけある"],
    animals: ['ペンギン', 'ライオン', 'うさぎ', 'パンダ', 'キツネ', 'ネコ', 'シバ犬', 'ゾウ', 'フクロウ', 'ハムスター', 'カワウソ',
     'コアラ', 'ゴリラ', 'イルカ',"アヒル","タヌキ","レッサーパンダ","アルパカ","ワニ","カメ","モモンガ","サメ","トラ","ナマケモノ",
     "ペリカン","カピバラ","オオカミ","チンパンジー","クラゲ","ロボット","魔法使い","剣","王冠","おにぎり","宇宙船","スライム","忍者",
     "おばけ","ドラゴン","時計","自動販売機","探検家","博士","パン","きのこ","カラス","スズメ","ハト","トカゲ","カエル","カタツムリ",
     "ミミズ","クモ","カマキリ","セミ","ホタル","チョウ","ミツバチ","アリ","クジラ","シャチ","マンボウ","ウミウシ","ヒトデ","ナマズ",
     "ドジョウ","教師","校長","クラブ長","委員長","リーダー","司会者","審判","飼育員","歌手","アイドル","探偵","案内人","ユーチューバー",
     "先生","旅人","校長先生","見習い","弟子","修行者","挑戦者","教頭先生","お笑い芸人"]
};

const AVAILABLE_KEYS = ['A','S','D','F','G','H','J','K','L','Z','X','C','V','B','N','M','Q','W','E','R','T','Y','U','I','O','P'];
const KEY_CODE_MAP = {};
AVAILABLE_KEYS.forEach(k => KEY_CODE_MAP[`Key${k}`] = k);

let playerCount = 2;

function setPlayerCount(n) {
    playerCount = n;
    document.querySelectorAll('.select-btn').forEach(b => b.classList.remove('selected'));
    document.querySelectorAll('.select-btn')[n-2].classList.add('selected');
}

function shuffle(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

/**
 * Audio Manager
 */
class AudioManager {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
        this.bgmTimer = null;
        this.bgmNote = 0;
        this.bgmTempo = 500;
    }

    resume() {
        if(this.ctx.state === 'suspended') this.ctx.resume();
    }

    playTone(freq, type, duration, vol = 1, slide = false) {
        this.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if(slide) {
            osc.frequency.exponentialRampToValueAtTime(freq * 2, this.ctx.currentTime + duration);
        }
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playSlotTick() {
        // Wooden block sound / Click
        this.playTone(800, 'square', 0.05, 0.2);
    }

    playSlotDecide() {
        // Ding!
        this.playTone(1200, 'sine', 0.3, 0.6);
        setTimeout(() => this.playTone(2400, 'triangle', 0.4, 0.4), 50);
    }

    playHit() {
        this.playTone(880, 'sine', 0.1, 0.7);
        setTimeout(() => this.playTone(1760, 'sine', 0.2, 0.5), 50);
    }

    playResonance(tier) {
        if (tier === 1) {
            [523.25, 659.25, 783.99, 1046.50, 1318.51, 2093.00].forEach((f, i) => {
                setTimeout(() => this.playTone(f, 'sine', 0.6, 0.6), i * 40);
            });
        } else if (tier === 2) {
            [523.25, 659.25, 783.99, 1046.50].forEach((f, i) => {
                setTimeout(() => this.playTone(f, 'triangle', 0.5, 0.5), i * 50);
            });
        } else {
            this.playTone(523.25, 'triangle', 0.3, 0.5);
            setTimeout(() => this.playTone(783.99, 'triangle', 0.4, 0.5), 100);
        }
    }

    playMiss() {
        this.playTone(150, 'sawtooth', 0.2, 0.4);
        this.playTone(100, 'square', 0.2, 0.4);
    }

    startBGM() {
        this.resume();
        this.stopBGM();
        this.bgmLoop();
    }

    bgmLoop() {
        const f = this.bgmNote % 4 === 0 ? 220 : 110;
        this.playTone(f, 'sine', 0.1, 0.15);
        this.bgmNote++;
        this.bgmTimer = setTimeout(() => this.bgmLoop(), this.bgmTempo);
    }

    setTempo(percentDone) {
        this.bgmTempo = 500 - (350 * percentDone);
    }

    stopBGM() {
        clearTimeout(this.bgmTimer);
    }
}

/**
 * Visual Effects
 */
class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 12;
        this.vy = (Math.random() - 0.5) * 12;
        this.life = 1.0;
        this.color = color;
        this.size = Math.random() * 6 + 3;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.life -= 0.025;
        this.size *= 0.94;
    }
    draw(ctx) {
        ctx.globalAlpha = this.life;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class FloatingScore {
    constructor(x, y, text, color) {
        this.x = x;
        this.y = y;
        this.text = text;
        this.color = color;
        this.life = 1.0;
        this.vy = -3;
    }
    update() {
        this.y += this.vy;
        this.life -= 0.02;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.font = "bold 40px 'Segoe UI'";
        ctx.fillStyle = this.color;
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.textAlign = "center";
        ctx.strokeText(this.text, this.x, this.y);
        ctx.fillText(this.text, this.x, this.y);
        ctx.globalAlpha = 1.0;
    }
}

class FloatingText {
    constructor(name, key, color, width, height) {
        this.name = name;
        this.key = key;
        this.color = color;
        this.width = width;
        this.height = height;
        this.resetPosition();
        
        this.isActive = false;
        this.isDone = false;
        this.scale = 1;
        this.targetScale = 1;
        this.activeTimer = 0;
        this.hitTimestamp = 0;
    }

    resetPosition() {
        this.x = Math.random() * (this.width - 300) + 150;
        this.y = Math.random() * (this.height - 300) + 150;
        this.vx = (Math.random() - 0.5) * 1.5;
        this.vy = (Math.random() - 0.5) * 1.5;
    }

    update(w, h, dt) {
        this.x += this.vx;
        this.y += this.vy;

        if (this.x < 80 || this.x > w - 80) this.vx *= -1;
        if (this.y < 80 || this.y > h - 80) this.vy *= -1;

        this.scale += (this.targetScale - this.scale) * 0.1;

        if (this.isActive) {
            this.activeTimer -= dt;
            if (this.activeTimer <= 0 && !this.isDone) {
                this.deactivate(); 
                return 'miss';
            }
        }
        return null;
    }

    activate(duration) {
        this.isActive = true;
        this.isDone = false;
        this.activeTimer = duration;
        this.targetScale = 2.0;
        this.hitTimestamp = 0;
    }

    deactivate(success = false) {
        this.isActive = false;
        this.targetScale = 1;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);

        if (this.isActive && !this.isDone) {
            ctx.shadowBlur = 40;
            ctx.shadowColor = this.color;
            ctx.fillStyle = '#fff';
        } else if (this.isDone) {
            ctx.shadowBlur = 60;
            ctx.shadowColor = '#fff';
            ctx.fillStyle = '#fff'; 
        } else {
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        }

        ctx.font = "bold 26px 'Segoe UI'";
        ctx.textAlign = "center";
        ctx.fillText(this.name, 0, -20);
        
        ctx.font = "bold 32px monospace";
        ctx.fillStyle = this.isActive ? this.color : 'rgba(255,255,255,0.1)';
        ctx.fillText(`[${this.key}]`, 0, 25);

        if (this.isActive && !this.isDone) {
            ctx.beginPath();
            ctx.arc(0, 0, 80, 0, Math.PI * 2 * (this.activeTimer / CONSTANTS.TARGET_DURATION));
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 4;
            ctx.stroke();
        }

        ctx.restore();
    }
}

/**
 * Main Game Logic
 */
class Game {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.audio = new AudioManager();
        this.particles = [];
        this.floatScores = [];
        this.players = [];
        this.state = 'SETTING'; 
        this.score = 0;
        this.prepInterval = null;
        
        window.addEventListener('resize', () => this.resize());
        this.resize();

        window.addEventListener('keydown', (e) => this.handleInput(e));
        
        this.lastTime = performance.now();
        requestAnimationFrame((t) => this.loop(t));
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    }

    // スロットシーケンス開始
    startSlotSequence() {
        this.audio.resume();
        this.score = 0;
        this.players = [];
        document.getElementById('key-guides').innerHTML = ''; // Reset UI
        
        // Hide Start/Result
        document.getElementById('start-screen').classList.remove('active');
        document.getElementById('result-screen').classList.remove('active');
        
        // Show Slot Screen
        document.getElementById('slot-screen').classList.add('active');
        
        const shuffledKeys = shuffle([...AVAILABLE_KEYS]);
        const usedAdj = new Set();
        const usedAni = new Set();
        
        let pIndex = 0;
        
        const runSlot = () => {
            if (pIndex >= playerCount) {
                setTimeout(() => {
                    document.getElementById('slot-screen').classList.remove('active');
                    this.initPrep();
                }, 1000);
                return;
            }

            // Update Label
            document.getElementById('slot-player-label').textContent = `Player ${pIndex + 1}`;
            document.getElementById('slot-name').style.color = '#fff';
            document.getElementById('slot-key').style.color = CONSTANTS.COLORS[pIndex % CONSTANTS.COLORS.length];

            const key = shuffledKeys[pIndex];
            const color = CONSTANTS.COLORS[pIndex % CONSTANTS.COLORS.length];
            
            // Random rolling
            let rolls = 0;
            const maxRolls = 20; // frame count
            const rollInterval = setInterval(() => {
                const adj = WORDS.adjectives[Math.floor(Math.random() * WORDS.adjectives.length)];
                const ani = WORDS.animals[Math.floor(Math.random() * WORDS.animals.length)];
                const k = AVAILABLE_KEYS[Math.floor(Math.random() * AVAILABLE_KEYS.length)];
                
                document.getElementById('slot-name').textContent = `${adj}${ani}`;
                document.getElementById('slot-key').textContent = k;
                this.audio.playSlotTick();
                
                rolls++;
                if (rolls > maxRolls) {
                    clearInterval(rollInterval);
                    finalizePlayer();
                }
            }, 80);

            const finalizePlayer = () => {
                // Determine final
                let adj, ani;
                do { adj = WORDS.adjectives[Math.floor(Math.random() * WORDS.adjectives.length)]; } while(usedAdj.has(adj));
                do { ani = WORDS.animals[Math.floor(Math.random() * WORDS.animals.length)]; } while(usedAni.has(ani));
                usedAdj.add(adj);
                usedAni.add(ani);
                
                const name = `${adj}${ani}`;
                document.getElementById('slot-name').textContent = name;
                document.getElementById('slot-name').style.color = color;
                document.getElementById('slot-key').textContent = key;
                this.audio.playSlotDecide();
                this.createExplosion(this.canvas.width/2, this.canvas.height/2, color);

                // Add to game logic
                const p = new FloatingText(name, key, color, this.canvas.width, this.canvas.height);
                this.players.push(p);

                // Add to Bottom UI
                const guideContainer = document.getElementById('key-guides');
                const guide = document.createElement('div');
                guide.className = 'key-guide-item pop-in';
                guide.style.borderColor = color;
                guide.style.boxShadow = `0 0 10px ${color}40`;
                guide.innerHTML = `
                    <span class="key-guide-key" style="color:${color}">${key}</span>
                    <span class="key-guide-name">${name}</span>
                `;
                guideContainer.appendChild(guide);

                pIndex++;
                setTimeout(runSlot, 800);
            };
        };

        runSlot();
    }

    initPrep() {
        document.getElementById('prep-screen').classList.add('active');
        document.getElementById('key-guides').style.display = 'flex';
        
        this.state = 'PREP';
        let timeLeft = CONSTANTS.PREP_DURATION;
        const timerEl = document.getElementById('prep-timer');
        timerEl.textContent = timeLeft;

        clearInterval(this.prepInterval);
        this.prepInterval = setInterval(() => {
            timeLeft--;
            timerEl.textContent = timeLeft;
            if (timeLeft <= 0) {
                this.skipPrep();
            }
        }, 1000);
    }

    skipPrep() {
        clearInterval(this.prepInterval);
        document.getElementById('prep-screen').classList.remove('active');
        this.startCountdown();
    }

    startCountdown() {
        this.state = 'COUNTDOWN';
        document.getElementById('countdown-screen').classList.add('active');
        this.audio.startBGM();
        
        let count = 3;
        const el = document.getElementById('countdown-display');
        el.textContent = count;
        
        const interval = setInterval(() => {
            count--;
            if (count > 0) {
                el.textContent = count;
                this.audio.playTone(440 + (3-count)*100, 'sine', 0.1, 0.5);
            } else {
                clearInterval(interval);
                el.textContent = 'GO!';
                this.audio.playTone(880, 'square', 0.3, 0.5);
                setTimeout(() => {
                    document.getElementById('countdown-screen').classList.remove('active');
                    this.start();
                }, 500);
            }
        }, 1000);
    }

    start() {
        this.state = 'PLAYING';
        this.timeLeft = CONSTANTS.GAME_DURATION;
        this.spawnTimer = 0;
        this.particles = [];
        this.floatScores = [];
        
        // Reset player positions for gameplay
        this.players.forEach(p => p.resetPosition());

        document.getElementById('game-hud').style.display = 'flex';
        document.getElementById('timer-bar').style.display = 'block';
        this.updateHUD();
    }

    end() {
        this.state = 'RESULT';
        this.audio.stopBGM();
        document.getElementById('game-hud').style.display = 'none';
        document.getElementById('timer-bar').style.display = 'none';
        
        document.getElementById('result-screen').classList.add('active');
        document.getElementById('result-score').textContent = this.score;
        
        this.saveScore(this.score, this.players.map(p => p.name).join(', '));
        this.showLeaderboard();

        let comment = "ナイスファイト！";
        if (this.score > 200) comment = "素晴らしいチームワーク！";
        if (this.score > 500) comment = "神がかった連携！伝説級！";
        document.getElementById('result-comment').textContent = comment;
    }

    saveScore(score, teamName) {
        const MAX_SCORES = 5;
        try {
            let scores = JSON.parse(localStorage.getItem('pikatto_scores') || '[]');
            scores.push({ score: score, name: teamName, date: new Date().toLocaleDateString() });
            scores.sort((a, b) => b.score - a.score);
            scores = scores.slice(0, MAX_SCORES);
            localStorage.setItem('pikatto_scores', JSON.stringify(scores));
        } catch(e) { console.error("Storage failed", e); }
    }

    showLeaderboard() {
        const list = document.getElementById('leaderboard');
        list.innerHTML = '';
        try {
            const scores = JSON.parse(localStorage.getItem('pikatto_scores') || '[]');
            scores.slice(0, 3).forEach((s, i) => {
                const row = document.createElement('div');
                row.className = 'rank-row';
                row.innerHTML = `
                    <span class="rank-num">${i+1}.</span>
                    <span class="rank-names">${s.name}</span>
                    <span class="rank-score">${s.score}</span>
                `;
                list.appendChild(row);
            });
        } catch(e) {}
    }

    returnToTitle() {
        document.getElementById('result-screen').classList.remove('active');
        document.getElementById('key-guides').style.display = 'flex'; 
        document.getElementById('key-guides').innerHTML = ''; // Clear guides
        document.getElementById('start-screen').classList.add('active');
        this.state = 'SETTING';
        this.players = [];
    }

    handleInput(e) {
        if (this.state !== 'PLAYING') return;

        const code = e.code; 
        const keyChar = Object.keys(KEY_CODE_MAP).find(k => k === code) ? KEY_CODE_MAP[code] : null;
        if (!keyChar) return;

        const player = this.players.find(p => p.key === keyChar);
        if (!player) return;

        const now = Date.now();

        if (player.isActive && !player.isDone) {
            player.isDone = true;
            player.hitTimestamp = now;
            this.createExplosion(player.x, player.y, player.color);

            const activePlayers = this.players.filter(p => p.isActive);
            
            if (activePlayers.length === 1) {
                this.audio.playHit();
                this.addScore(10, player.x, player.y, "HIT!");
                setTimeout(() => player.deactivate(true), 200);
            } else {
                const partner = activePlayers.find(p => p !== player);
                if (partner && partner.isDone) {
                    const delta = Math.abs(player.hitTimestamp - partner.hitTimestamp);
                    let points = 0;
                    let text = "";
                    let color = "#fff";

                    if (delta <= CONSTANTS.RESONANCE_WINDOW_1) {
                        points = 100; text = "PERFECT!!"; color = "var(--perfect)";
                        this.audio.playResonance(1);
                    } else if (delta <= CONSTANTS.RESONANCE_WINDOW_2) {
                        points = 50; text = "GREAT!"; color = "var(--great)";
                        this.audio.playResonance(2);
                    } else if (delta <= CONSTANTS.RESONANCE_WINDOW_3) {
                        points = 20; text = "GOOD"; color = "var(--good)";
                        this.audio.playResonance(3);
                    } else {
                        points = 10; text = "HIT";
                        this.audio.playHit();
                    }

                    this.addScore(points, (player.x + partner.x)/2, (player.y + partner.y)/2, text, color);
                    this.resonanceLine = { p1: player, p2: partner, life: 1.0, color: color };
                    setTimeout(() => {
                        player.deactivate(true);
                        partner.deactivate(true);
                    }, 300);
                } else {
                    this.audio.playTone(1200, 'sine', 0.05, 0.3);
                }
            }

        } else {
            if (!player.isActive) {
                this.audio.playMiss();
                this.score = Math.max(0, this.score - 5);
                this.updateHUD();
                player.vx += (Math.random()-0.5)*30; 
                this.addScore(-5, player.x, player.y, "MISS...", "#aaa");
            }
        }
    }

    addScore(points, x, y, label, color="#fff") {
        this.score += points;
        this.updateHUD();
        this.floatScores.push(new FloatingScore(x, y - 40, label ? `+${points} ${label}` : `+${points}`, color));
        
        const scoreEl = document.getElementById('score-display');
        scoreEl.style.transform = 'scale(1.3)';
        scoreEl.style.color = color;
        setTimeout(() => {
            scoreEl.style.transform = 'scale(1)';
            scoreEl.style.color = '';
        }, 150);
    }

    createExplosion(x, y, color) {
        for(let i=0; i<15; i++) {
            this.particles.push(new Particle(x, y, color));
        }
    }

    updateHUD() {
        document.getElementById('score-display').textContent = `Score: ${this.score}`;
        document.getElementById('time-display').textContent = `Time: ${Math.ceil(this.timeLeft)}`;
        document.getElementById('timer-bar').style.width = `${(this.timeLeft / CONSTANTS.GAME_DURATION) * 100}%`;
    }

    loop(currentTime) {
        const dt = currentTime - this.lastTime;
        this.lastTime = currentTime;

        this.ctx.fillStyle = 'rgba(15, 12, 41, 0.4)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Draw Particles (Always visible)
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.update();
            p.draw(this.ctx);
            if (p.life <= 0) this.particles.splice(i, 1);
        }

        // Draw Float Scores (Always visible)
        for (let i = this.floatScores.length - 1; i >= 0; i--) {
            const fs = this.floatScores[i];
            fs.update();
            fs.draw(this.ctx);
            if (fs.life <= 0) this.floatScores.splice(i, 1);
        }

        if (this.state === 'RESULT') {
            // In result screen, do NOT draw players
            requestAnimationFrame((t) => this.loop(t));
            return;
        }

        if (this.state === 'PLAYING') {
            this.timeLeft -= dt / 1000;
            if (this.timeLeft <= 0) {
                this.end();
            }

            this.audio.setTempo(1 - (this.timeLeft / CONSTANTS.GAME_DURATION));

            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                const progress = 1 - (this.timeLeft / CONSTANTS.GAME_DURATION);
                const currentRate = CONSTANTS.BASE_SPAWN_RATE - (progress * (CONSTANTS.BASE_SPAWN_RATE - CONSTANTS.MIN_SPAWN_RATE));
                
                this.spawnTimer = currentRate;
                
                const inactivePlayers = this.players.filter(p => !p.isActive);
                if (inactivePlayers.length > 0) {
                    const isResonance = Math.random() < CONSTANTS.RESONANCE_CHANCE && inactivePlayers.length >= 2;
                    
                    if (isResonance) {
                        const p1 = inactivePlayers.splice(Math.floor(Math.random() * inactivePlayers.length), 1)[0];
                        const p2 = inactivePlayers.splice(Math.floor(Math.random() * inactivePlayers.length), 1)[0];
                        p1.activate(CONSTANTS.TARGET_DURATION);
                        p2.activate(CONSTANTS.TARGET_DURATION);
                    } else {
                        const p1 = inactivePlayers.splice(Math.floor(Math.random() * inactivePlayers.length), 1)[0];
                        p1.activate(CONSTANTS.TARGET_DURATION);
                    }
                }
            }
            this.updateHUD();
        }

        if (this.resonanceLine) {
            this.resonanceLine.life -= 0.08;
            if (this.resonanceLine.life > 0) {
                const { p1, p2, life, color } = this.resonanceLine;
                this.ctx.save();
                this.ctx.beginPath();
                this.ctx.moveTo(p1.x, p1.y);
                this.ctx.lineTo(p2.x, p2.y);
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = 15 * life;
                this.ctx.lineCap = 'round';
                this.ctx.globalAlpha = life;
                this.ctx.shadowBlur = 30;
                this.ctx.shadowColor = color;
                this.ctx.stroke();
                this.ctx.restore();
            } else {
                this.resonanceLine = null;
            }
        }

        // Only draw players if NOT in RESULT state (Handled by the check above, but players update needed)
        this.players.forEach(p => {
            const result = p.update(this.canvas.width, this.canvas.height, dt);
            if (result === 'miss') {
                this.audio.playMiss();
                this.score = Math.max(0, this.score - 5);
                this.addScore(-5, p.x, p.y, "MISS...", "#aaa");
            }
            // Draw players during PLAYING or PREP or SETTING (if valid)
            if (this.state !== 'RESULT') {
                p.draw(this.ctx);
            }
        });

        requestAnimationFrame((t) => this.loop(t));
    }
}

const game = new Game();

</script>
</body>
</html>