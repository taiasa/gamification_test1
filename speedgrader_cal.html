<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SpeedGrader Dash - Visual Fix</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=DotGothic16&display=swap');
        
        body {
            background-color: #1a1a2e;
            color: #ffffff;
            font-family: 'DotGothic16', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        canvas {
            image-rendering: pixelated;
            max-width: 100%;
            max-height: 80vh;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.3);
            border-radius: 12px;
            background: #16213e;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            pointer-events: none;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            z-index: 10;
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px;
            border-radius: 10px;
            border: 2px solid #4ecca3;
            min-width: 120px;
        }

        .life-container {
            font-size: 2rem;
            color: #ff4b2b;
            text-shadow: 0 0 10px rgba(255, 75, 43, 0.5);
        }

        .radio-custom:checked + label {
            background-color: #0891b2;
            border-color: #22d3ee;
            color: white;
        }
    </style>
</head>
<body>

<div id="game-container">
    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-90 z-20">
        <h1 class="text-6xl font-bold mb-6 text-cyan-400">SpeedGrader Dash</h1>
        <p class="text-xl mb-6">Èõ£ÊòìÂ∫¶„ÇíÈÅ∏Êäû„Åó„Å¶Êé°ÁÇπ„ÇíÈñãÂßã„Åõ„ÇàÔºÅ</p>
        
        <div class="flex gap-4 mb-10">
            <div class="relative">
                <input type="radio" name="level" id="lv1" value="easy" class="hidden radio-custom" checked>
                <label for="lv1" class="px-6 py-3 border-2 border-gray-600 rounded-lg cursor-pointer hover:border-cyan-400 transition block text-center">
                    <span class="block text-lg">ÂàùÁ¥ö</span>
                    <span class="text-xs text-gray-400 text-nowrap">1Ê°Å ÂõõÂâá</span>
                </label>
            </div>
            <div class="relative">
                <input type="radio" name="level" id="lv2" value="medium" class="hidden radio-custom">
                <label for="lv2" class="px-6 py-3 border-2 border-gray-600 rounded-lg cursor-pointer hover:border-cyan-400 transition block text-center">
                    <span class="block text-lg">‰∏≠Á¥ö</span>
                    <span class="text-xs text-gray-400 text-nowrap">2Ê°Å„Å®1Ê°Å ÂõõÂâá</span>
                </label>
            </div>
            <div class="relative">
                <input type="radio" name="level" id="lv3" value="hard" class="hidden radio-custom">
                <label for="lv3" class="px-6 py-3 border-2 border-gray-600 rounded-lg cursor-pointer hover:border-cyan-400 transition block text-center">
                    <span class="block text-lg">‰∏äÁ¥ö</span>
                    <span class="text-xs text-gray-400 text-nowrap">% Ë®àÁÆóÔºà„Åã„ÅëÁÆóÔºâ</span>
                </label>
            </div>
        </div>

        <button id="start-btn" class="px-10 py-4 bg-cyan-600 hover:bg-cyan-500 text-white text-2xl rounded-full transition transform hover:scale-105 shadow-lg">
            Êé°ÁÇπÈñãÂßã
        </button>

        <div class="mt-8 grid grid-cols-2 gap-12 text-center text-gray-400">
            <div>
                <p class="text-emerald-400">Ê≠£Ëß£Ôºö[‚Üê] „Ç≠„Éº / Â∑¶„ÇØ„É™„ÉÉ„ÇØ</p>
            </div>
            <div>
                <p class="text-rose-400">‰∏çÊ≠£Ëß£Ôºö[‚Üí] „Ç≠„Éº / Âè≥„ÇØ„É™„ÉÉ„ÇØ</p>
            </div>
        </div>
    </div>

    <!-- UI Overlay -->
    <div class="ui-overlay">
        <div class="flex flex-col gap-2">
            <div class="stat-box">
                <div class="text-[10px] uppercase text-emerald-400">Score</div>
                <div id="score-display" class="text-3xl">0</div>
            </div>
            <div id="life-display" class="life-container">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
        </div>
        <div class="stat-box text-right h-fit">
            <div class="text-[10px] uppercase text-yellow-400">Combo</div>
            <div id="combo-display" class="text-3xl text-yellow-400">0</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <!-- Game Over Screen -->
    <div id="game-over" class="hidden absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-95 z-30">
        <h2 class="text-6xl font-bold mb-4 text-rose-600">MISSION FAILED</h2>
        <p class="text-2xl mb-2 text-white">ÊúÄÁµÇ„Çπ„Ç≥„Ç¢: <span id="final-score" class="text-cyan-400">0</span></p>
        <p class="text-xl mb-10 text-gray-400">ÊúÄÂ§ß„Ç≥„É≥„Éú: <span id="final-combo">0</span></p>
        <button id="restart-btn" class="px-8 py-4 bg-white text-black text-2xl rounded-full hover:bg-gray-200 transition">
            „Çø„Ç§„Éà„É´„Å∏Êàª„Çã
        </button>
    </div>
</div>

<script>
/**
 * SpeedGrader Dash - Optimized for Readability
 */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score-display');
const comboEl = document.getElementById('combo-display');
const lifeEl = document.getElementById('life-display');
const finalScoreEl = document.getElementById('final-score');
const finalComboEl = document.getElementById('final-combo');
const startScreen = document.getElementById('start-screen');
const gameOverScreen = document.getElementById('game-over');

// Audio Engine
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function playSound(freq, type = 'square', duration = 0.1, vol = 0.1) {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
}

const sounds = {
    correct: () => { playSound(600, 'sine', 0.1, 0.1); setTimeout(() => playSound(900, 'sine', 0.1, 0.1), 40); },
    wrong: () => { playSound(100, 'sawtooth', 0.4, 0.15); },
    lifeLost: () => { playSound(200, 'square', 0.2, 0.1); },
    combo: (c) => { playSound(400 + (c * 5), 'triangle', 0.15, 0.1); }
};

// Game State
let gameState = 'title';
let currentLevel = 'easy';
let score = 0;
let combo = 0;
let maxCombo = 0;
let lives = 3;
let speed = 1.8;
let tasks = [];
let particles = [];
let lastSpawn = 0;
let nextSpawnTime = 2000;
let screenShake = 0;

function resize() {
    canvas.width = 800;
    canvas.height = 600;
}
window.addEventListener('resize', resize);
resize();

class Task {
    constructor(level) {
        this.id = Math.random();
        this.x = canvas.width + 160; // Spawn a bit further back
        this.y = canvas.height / 2;
        // Adjusted card size for better visibility
        this.width = 320; 
        this.height = 160;
        this.rotation = (Math.random() - 0.5) * 0.03;
        
        const params = this.generateProblem(level);
        this.text = params.text;
        this.isCorrect = params.isCorrect;
    }

    generateProblem(level) {
        let a, b, op, actual, display, isCorrect = Math.random() > 0.5;
        
        switch(level) {
            case 'easy':
                op = ['+', '-', '√ó'][Math.floor(Math.random() * 3)];
                a = Math.floor(Math.random() * 9) + 1;
                b = Math.floor(Math.random() * 9) + 1;
                if (op === '-' && a < b) [a, b] = [b, a];
                actual = (op === '+') ? a + b : (op === '-') ? a - b : a * b;
                break;
                
            case 'medium':
                const mode = Math.random();
                if (mode < 0.3) {
                    a = Math.floor(Math.random() * 80) + 10;
                    b = Math.floor(Math.random() * 10) + 1;
                    op = Math.random() > 0.5 ? '+' : '-';
                } else if (mode < 0.7) {
                    a = Math.floor(Math.random() * 12) + 2;
                    b = Math.floor(Math.random() * 9) + 2;
                    op = '√ó';
                } else {
                    b = Math.floor(Math.random() * 8) + 2;
                    actual = Math.floor(Math.random() * 12) + 2;
                    a = b * actual;
                    op = '√∑';
                }
                if (op === '-' && a < b) [a, b] = [b, a];
                if (op !== '√∑') actual = (op === '+') ? a + b : (op === '-') ? a - b : a * b;
                break;
                
            case 'hard':
                const pList = [10, 20, 25, 50, 75, 5, 15];
                const p = pList[Math.floor(Math.random() * pList.length)];
                a = (Math.random() > 0.4) ? (Math.floor(Math.random() * 20) + 1) * 10 : (Math.floor(Math.random() * 15) + 1);
                actual = (a * p) / 100;
                actual = Math.round(actual * 100) / 100;
                
                return {
                    text: `${a} √ó ${p}% = ${isCorrect ? actual : (actual + (Math.random() > 0.5 ? 0.5 : 1.5)).toFixed(1)}`,
                    isCorrect: isCorrect
                };
        }

        display = isCorrect ? actual : actual + (Math.floor(Math.random() * 3) + 1) * (Math.random() > 0.5 ? 1 : -1);
        if (display < 0) display = Math.abs(display) + 1;

        return {
            text: `${a} ${op} ${b} = ${display}`,
            isCorrect: isCorrect
        };
    }

    update() {
        this.x -= speed;
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        
        // Improved Card Visuals
        ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
        ctx.shadowBlur = 15;
        ctx.shadowOffsetX = 5;
        ctx.shadowOffsetY = 5;

        // Card Surface
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
        
        ctx.shadowColor = 'transparent';
        ctx.strokeStyle = '#2c3e50';
        ctx.lineWidth = 4;
        ctx.strokeRect(-this.width/2, -this.height/2, this.width, this.height);

        // Drawing a small "Red Pen" style circle if judged correctly (feedback)
        // (This would happen after judge, but for now let's keep it simple and clean)

        // Subtle Notebook Lines
        ctx.strokeStyle = '#eef2f7';
        ctx.lineWidth = 1;
        for(let i = -this.height/2 + 20; i < this.height/2; i += 30) {
            ctx.beginPath();
            ctx.moveTo(-this.width/2 + 10, i);
            ctx.lineTo(this.width/2 - 10, i);
            ctx.stroke();
        }

        // Text with dynamic font size for readability
        let fontSize = 48;
        if (this.text.length > 10) fontSize = 40;
        if (this.text.length > 14) fontSize = 32;

        ctx.fillStyle = '#2c3e50';
        ctx.font = `bold ${fontSize}px "DotGothic16"`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(this.text, 0, 0);

        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 10;
        this.vy = (Math.random() - 0.5) * 10;
        this.alpha = 1;
        this.color = color;
        this.size = Math.random() * 6 + 2;
    }
    update() {
        this.x += this.vx;
        this.y += this.vy;
        this.alpha -= 0.03;
    }
    draw() {
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
    }
}

function createExplosion(x, y, color) {
    for(let i = 0; i < 20; i++) {
        particles.push(new Particle(x, y, color));
    }
}

function handleLifeLoss() {
    lives--;
    screenShake = 20;
    combo = 0;
    sounds.lifeLost();
    updateUI();
    if (lives <= 0) {
        gameOver();
    }
}

function judge(choice) {
    if (tasks.length === 0 || gameState !== 'playing') return;
    
    const target = tasks[0];
    if (target.x > canvas.width - 20) return;

    if (target.isCorrect === choice) {
        score += 10 + (combo * 5);
        combo++;
        if (combo > maxCombo) maxCombo = combo;
        speed += 0.02;
        sounds.correct();
        if (combo % 5 === 0) sounds.combo(combo);
        createExplosion(target.x, target.y, '#4ecca3');
    } else {
        handleLifeLoss();
        createExplosion(target.x, target.y, '#ff4b2b');
    }
    
    tasks.shift();
    updateUI();
}

function updateUI() {
    scoreEl.innerText = score;
    comboEl.innerText = combo;
    lifeEl.innerText = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(3 - lives);
}

function gameOver() {
    gameState = 'over';
    finalScoreEl.innerText = score;
    finalComboEl.innerText = maxCombo;
    gameOverScreen.classList.remove('hidden');
}

function gameLoop(time) {
    if (gameState !== 'playing') return;

    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (screenShake > 0) {
        ctx.save();
        ctx.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);
        screenShake *= 0.8;
    }

    // Spawn
    if (time - lastSpawn > nextSpawnTime) {
        tasks.push(new Task(currentLevel));
        lastSpawn = time;
        nextSpawnTime = Math.max(1300, 2400 - (speed * 120));
    }

    // BG grid
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    for(let i = 0; i < canvas.width; i += 60) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
    }

    // Red Deadline
    ctx.strokeStyle = '#ff4b2b';
    ctx.lineWidth = 3;
    ctx.setLineDash([20, 10]);
    ctx.beginPath();
    ctx.moveTo(100, 0); ctx.lineTo(100, canvas.height);
    ctx.stroke();
    ctx.setLineDash([]);

    // Update Tasks
    for (let i = tasks.length - 1; i >= 0; i--) {
        tasks[i].update();
        tasks[i].draw();

        if (tasks[i].x < 80) {
            tasks.splice(i, 1);
            handleLifeLoss();
        }
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].alpha <= 0) particles.splice(i, 1);
    }

    if (screenShake > 0.1) ctx.restore();

    requestAnimationFrame(gameLoop);
}

// Controls
window.addEventListener('keydown', (e) => {
    if (gameState !== 'playing') return;
    if (e.key === 'ArrowLeft') judge(true);
    if (e.key === 'ArrowRight') judge(false);
});

canvas.addEventListener('mousedown', (e) => {
    if (gameState !== 'playing') return;
    if (e.button === 0) judge(true);
    if (e.button === 2) judge(false);
});
canvas.addEventListener('contextmenu', e => e.preventDefault());

// UI Buttons
document.getElementById('start-btn').addEventListener('click', () => {
    if (audioCtx.state === 'suspended') audioCtx.resume();
    
    const radios = document.getElementsByName('level');
    for (const r of radios) {
        if (r.checked) currentLevel = r.value;
    }
    
    startScreen.classList.add('hidden');
    initGame();
});

document.getElementById('restart-btn').addEventListener('click', () => {
    gameOverScreen.classList.add('hidden');
    startScreen.classList.remove('hidden');
    gameState = 'title';
});

function initGame() {
    score = 0;
    combo = 0;
    maxCombo = 0;
    lives = 3;
    speed = currentLevel === 'easy' ? 1.4 : currentLevel === 'medium' ? 1.7 : 1.9;
    tasks = [];
    particles = [];
    gameState = 'playing';
    updateUI();
    requestAnimationFrame(gameLoop);
}

</script>
</body>
</html>