<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>部首ライダー - RADICAL RIDER</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020617;
            color: white;
            font-family: 'Orbitron', 'Hiragino Kaku Gothic ProN', sans-serif;
            touch-action: none;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            background: radial-gradient(circle at center, #1e1b4b 0%, #020617 100%);
        }
        #game-container::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0; left: 0; bottom: 0; right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.1) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.03), rgba(0, 255, 0, 0.01), rgba(0, 0, 255, 0.03));
            z-index: 5;
            background-size: 100% 3px, 3px 100%;
            pointer-events: none;
            opacity: 0.6;
        }
        canvas {
            background-color: #020617;
            box-shadow: 0 0 60px rgba(59, 130, 246, 0.3), inset 0 0 20px rgba(59, 130, 246, 0.2);
            border: 2px solid rgba(59, 130, 246, 0.5);
            border-radius: 8px;
            max-width: 95vw;
            max-height: 70vh;
            z-index: 1;
        }
        .ui-overlay {
            position: absolute;
            top: 20px;
            pointer-events: none;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }
        .stats-bar {
            display: flex;
            justify-content: space-between;
            width: 90%;
            max-width: 800px;
            font-size: 1.5rem;
            font-weight: 900;
            letter-spacing: 3px;
            text-shadow: 0 0 10px #3b82f6;
        }
        #combo-container {
            margin-top: 10px;
            text-align: center;
            transition: transform 0.1s;
        }
        .combo-text {
            font-size: 5rem;
            font-weight: 900;
            color: #fbbf24;
            text-shadow: 0 0 30px rgba(251, 191, 36, 0.9);
            line-height: 1;
        }
        #quiz-overlay {
            position: absolute;
            background: rgba(2, 6, 23, 0.95);
            backdrop-filter: blur(10px);
            padding: 40px;
            border: 4px solid #facc15;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 1000;
            pointer-events: auto;
            width: 95%;
            max-width: 650px;
            box-shadow: 0 0 200px rgba(250, 204, 21, 0.4);
            border-radius: 20px;
        }
        .quiz-option {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9));
            padding: 24px;
            margin: 10px;
            border-radius: 12px;
            font-size: 2rem;
            cursor: pointer;
            transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            border: 1px solid rgba(255,255,255,0.1);
            width: 100%;
            text-align: center;
            font-weight: bold;
            color: #94a3b8;
        }
        .quiz-option:hover { 
            background: #facc15;
            color: #020617;
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(250, 204, 21, 0.6);
        }
        .hidden { display: none !important; }
        #start-screen, #result-screen {
            position: absolute;
            inset: 0;
            background: #020617;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        .btn-glitch {
            position: relative;
            width: 320px;
            padding: 25px;
            margin: 15px;
            font-size: 1.6rem;
            font-weight: 900;
            background: transparent;
            color: white;
            border: 2px solid #3b82f6;
            cursor: pointer;
            overflow: hidden;
            transition: 0.3s;
            text-transform: uppercase;
            letter-spacing: 4px;
        }
        .btn-glitch:hover {
            background: #3b82f6;
            box-shadow: 0 0 50px rgba(59, 130, 246, 0.8);
            transform: translateY(-5px);
        }
        .score-pop {
            position: absolute;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            pointer-events: none;
            animation: scoreFloat 0.8s cubic-bezier(0.18, 0.89, 0.32, 1.28) forwards;
            z-index: 500;
            font-size: 2rem;
        }
        @keyframes scoreFloat {
            0% { transform: scale(0.5) translateY(0); opacity: 0; }
            50% { opacity: 1; transform: scale(1.2) translateY(-50px); }
            100% { transform: scale(1.0) translateY(-120px); opacity: 0; }
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="start-screen">
        <h1 class="text-7xl md:text-9xl font-black mb-2 text-white italic tracking-tighter uppercase" style="text-shadow: 5px 5px 0px #3b82f6, -3px -3px 0px #ef4444;">部首<br>RIDER</h1>
        <p class="text-yellow-400 mb-12 tracking-[0.5em] font-bold text-xl animate-pulse">システム起動中...</p>
        <div class="flex flex-col items-center">
            <button class="btn-glitch" onclick="startGame('relax')">リラックスモード</button>
            <button class="btn-glitch" style="border-color:#ef4444; color:#ef4444;" onclick="startGame('hard')">オーバードライブ</button>
        </div>
        <p class="mt-16 text-slate-500 text-sm uppercase tracking-widest">移動: 矢印キー / WASD • 20コンボごとにクイズ発生</p>
    </div>

    <div id="result-screen" class="hidden">
        <h2 class="text-4xl font-bold mb-4 text-blue-400 tracking-widest uppercase">ドライブ終了</h2>
        <div class="text-9xl font-black mb-6 text-white" id="final-score">0</div>
        <div id="final-stats" class="text-2xl text-yellow-400 mb-12 font-bold"></div>
        <button onclick="location.reload()" class="px-16 py-6 bg-white text-black font-black text-2xl hover:bg-blue-500 hover:text-white transition-all transform hover:scale-110">再起動</button>
    </div>

    <div id="quiz-overlay" class="hidden">
        <div id="quiz-pending-count" class="text-blue-400 font-bold mb-1 tracking-widest text-xs">残り問題数: 0</div>
        <div class="text-yellow-400 font-black mb-4 tracking-[0.4em] text-lg animate-bounce">緊急チャレンジ</div>
        <div id="quiz-progress" class="text-slate-400 font-bold mb-8 tracking-widest text-sm">発見した部首: 1 / 50</div>
        <div id="quiz-question" class="text-[12rem] font-bold mb-10 text-white leading-none filter drop-shadow(0 0 30px #fff)">氵</div>
        <div id="quiz-options" class="grid grid-cols-1 gap-4 w-full"></div>
    </div>

    <div id="ui-overlay" class="ui-overlay hidden">
        <div class="stats-bar">
            <div>スコア: <span id="score" class="text-white">0</span></div>
            <div id="timer-display">残り時間: <span id="timer" class="text-red-500">30.0</span>秒</div>
        </div>
        <div id="combo-container" class="hidden">
            <span class="combo-text" id="combo-count">00</span>
            <div class="text-sm tracking-[0.8em] text-yellow-500 font-black uppercase">コンボ</div>
            <div class="w-80 bg-slate-900/80 h-2 mt-4 mx-auto overflow-hidden rounded-full border border-yellow-500/30">
                <div id="combo-bar" class="bg-yellow-400 h-full w-full shadow-[0_0_15px_#fbbf24]"></div>
            </div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>
</div>

<script>
/** オーディオ設定 */
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
function playSound(type, freq = 440) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain); gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if (type === 'move') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(150, now + 0.08);
        gain.gain.setValueAtTime(0.15, now); gain.gain.linearRampToValueAtTime(0, now + 0.08);
        osc.start(); osc.stop(now + 0.08);
    } else if (type === 'hit') {
        osc.type = 'square'; osc.frequency.setValueAtTime(freq * 0.5, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.15);
        gain.gain.setValueAtTime(0.4, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(); osc.stop(now + 0.15);
    } else if (type === 'correct') {
        osc.type = 'sine'; osc.frequency.setValueAtTime(440, now);
        osc.frequency.exponentialRampToValueAtTime(880, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1760, now + 0.4);
        gain.gain.setValueAtTime(0.3, now); gain.gain.linearRampToValueAtTime(0, now + 0.5);
        osc.start(); osc.stop(now + 0.5);
    } else if (type === 'wrong') {
        osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(100, now + 0.3);
        gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
        osc.start(); osc.stop(now + 0.3);
    }
}

/** データ定義 */
const MASTER_RADICAL_LIST = [
    { q: "氵", a: "さんずい", opts: ["さんずい", "にすい", "したみず"] },
    { q: "亻", a: "にんべん", opts: ["にんべん", "ぎょうにんべん", "けものへん"] },
    { q: "扌", a: "てへん", opts: ["てへん", "つくり", "ほこづくり"] },
    { q: "彳", a: "ぎょうにんべん", opts: ["ぎょうにんべん", "にんべん", "いとへん"] },
    { q: "艹", a: "くさかんむり", opts: ["くさかんむり", "たけかんむり", "あめかんむり"] },
    { q: "宀", a: "うかんむり", opts: ["うかんむり", "わかんむり", "あなかんむり"] },
    { q: "辶", a: "しんにょう", opts: ["しんにょう", "えんにょう", "かんにょう"] },
    { q: "阝(左)", a: "こざとへん", opts: ["こざとへん", "おおざと", "のぎへん"] },
    { q: "阝(右)", a: "おおざと", opts: ["おおざと", "こざとへん", "つくり"] },
    { q: "刂", a: "りっとう", opts: ["りっとう", "かたなへん", "のぶん"] },
    { q: "犭", a: "けものへん", opts: ["けものへん", "にんべん", "さんずい"] },
    { q: "礻", a: "しめすへん", opts: ["しめすへん", "ころもへん", "のぎへん"] },
    { q: "攵", a: "のぶん", opts: ["のぶん", "ぼくづくり", "あくび"] },
    { q: "欠", a: "あくび", opts: ["あくび", "のぶん", "るまた"] },
    { q: "疒", a: "やまいだれ", opts: ["やまいだれ", "まだれ", "かばね"] },
    { q: "广", a: "まだれ", opts: ["まだれ", "やまいだれ", "しかばね"] },
    { q: "貝", a: "かいへん", opts: ["かいへん", "めへん", "たまへん"] },
    { q: "言", a: "ごんべん", opts: ["ごんべん", "にんべん", "いとへん"] },
    { q: "衤", a: "ころもへん", opts: ["ころもへん", "しめすへん", "いとへん"] },
    { q: "禾", a: "のぎへん", opts: ["のぎへん", "きへん", "いとへん"] },
    { q: "虫", a: "むしへん", opts: ["むしへん", "けものへん", "さかなへん"] },
    { q: "足", a: "あしへん", opts: ["あしへん", "みへん", "くるまへん"] },
    { q: "酉", a: "とりへん", opts: ["とりへん", "さかなへん", "むしへん"] },
    { q: "釒", a: "かねへん", opts: ["かねへん", "いしへん", "たまへん"] },
    { q: "虍", a: "とらかんむり", opts: ["とらかんむり", "むしかんむり", "あなかんむり"] },
    { q: "門", a: "もんがまえ", opts: ["もんがまえ", "くにがまえ", "ぎょうがまえ"] },
    { q: "囗", a: "くにがまえ", opts: ["くにがまえ", "もんがまえ", "しかばね"] },
    { q: "尸", a: "しかばね", opts: ["しかばね", "まだれ", "やまいだれ"] },
    { q: "目", a: "めへん", opts: ["めへん", "ひへん", "かねへん"] },
    { q: "日", a: "ひへん", opts: ["ひへん", "めへん", "かねへん"] },
    { q: "月", a: "にくづき", opts: ["にくづき", "つきへん", "ふねへん"] },
    { q: "舟", a: "ふねへん", opts: ["ふねへん", "にくづき", "くるまへん"] },
    { q: "車", a: "くるまへん", opts: ["くるまへん", "ふねへん", "かねへん"] },
    { q: "馬", a: "うまへん", opts: ["うまへん", "しかへん", "とりへん"] },
    { q: "鳥", a: "とりへん", opts: ["とりへん", "うまへん", "さかなへん"] },
    { q: "魚", a: "さかなへん", opts: ["さかなへん", "とりへん", "むしへん"] },
    { q: "竹", a: "たけかんむり", opts: ["たけかんむり", "くさかんむり", "あめかんむり"] },
    { q: "雨", a: "あめかんむり", opts: ["あめかんむり", "たけかんむり", "うかんむり"] },
    { q: "田", a: "たへん", opts: ["たへん", "いしへん", "のぎへん"] },
    { q: "石", a: "いしへん", opts: ["いしへん", "かねへん", "たまへん"] },
    { q: "王", a: "たまへん", opts: ["たまへん", "かねへん", "いしへん"] },
    { q: "巾", a: "はばへん", opts: ["はばへん", "いとへん", "ころもへん"] },
    { q: "糸", a: "いとへん", opts: ["いとへん", "はばへん", "ごんべん"] },
    { q: "耳", a: "みみへん", opts: ["みみへん", "めへん", "くちへん"] },
    { q: "土", a: "つちへん", opts: ["つちへん", "おんなへん", "きへん"] },
    { q: "女", a: "おんなへん", opts: ["おんなへん", "つちへん", "にんべん"] },
    { q: "弓", a: "ゆみへん", opts: ["ゆみへん", "かたなへん", "ほこづくり"] },
    { q: "身", a: "みへん", opts: ["みへん", "あしへん", "くるまへん"] },
    { q: "示", a: "しめす", opts: ["しめす", "ころも", "いと"] },
    { q: "衣", a: "ころも", opts: ["ころも", "しめす", "はば"] }
];

/** ゲーム定数と変数 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const timerEl = document.getElementById('timer');
const comboEl = document.getElementById('combo-count');
const comboContainer = document.getElementById('combo-container');
const comboBar = document.getElementById('combo-bar');

const CELL_COUNT = 9;
let cellSize, width, height;

let player = { gridX: 4, gridY: 4, vX: 4, vY: 4, tilt: 0, score: 0, combo: 0, comboTimer: 0, maxCombo: 0 };
let enemies = [];
let particles = [];
let usedQuizzes = [];
let gameStarted = false, isGameOver = false, isPaused = false;
let lastTime = 0, spawnTimer = 0, timeLeft = 30.0, shake = 0;
let moveCooldown = 0;
let gameMode = 'relax';
const keys = {};

// クイズ管理用
let quizPendingCount = 0; 
let resetComboOnResume = false; // クイズ終了後にコンボをリセットするか

function resize() {
    const size = Math.min(window.innerWidth * 0.95, window.innerHeight * 0.7);
    canvas.width = canvas.height = width = height = size;
    cellSize = size / CELL_COUNT;
}
window.addEventListener('resize', resize);
resize();

function spawnEnemy() {
    if (isPaused || isGameOver) return;
    const limit = gameMode === 'hard' ? 55 : 25;
    if (enemies.length > limit) return;
    let x, y, attempts = 0;
    do {
        x = Math.floor(Math.random() * CELL_COUNT);
        y = Math.floor(Math.random() * CELL_COUNT);
        attempts++;
    } while (attempts < 10 && Math.abs(x - player.gridX) + Math.abs(y - player.gridY) < 2);
    enemies.push({ gridX: x, gridY: y, vX: x, vY: y, moveTimer: 0, isRare: Math.random() < (gameMode === 'hard' ? 0.2 : 0.1), phase: Math.random() * Math.PI * 2 });
}

function handleInput(dt) {
    if (isPaused || isGameOver) return;
    moveCooldown -= dt;
    if (moveCooldown <= 0) {
        let dx = 0, dy = 0;
        if (keys['arrowup'] || keys['w']) dy = -1;
        else if (keys['arrowdown'] || keys['s']) dy = 1;
        else if (keys['arrowleft'] || keys['a']) dx = -1;
        else if (keys['arrowright'] || keys['d']) dx = 1;
        if (dx !== 0 || dy !== 0) {
            const nx = Math.max(0, Math.min(CELL_COUNT-1, player.gridX + dx));
            const ny = Math.max(0, Math.min(CELL_COUNT-1, player.gridY + dy));
            if (nx !== player.gridX || ny !== player.gridY) {
                player.gridX = nx; player.gridY = ny; player.tilt = dx * 0.5;
                playSound('move'); checkHit(); moveCooldown = 0.07;
            }
        } else { player.tilt *= 0.8; }
    }
}

function checkHit() {
    if (!enemies || enemies.length === 0) return;
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (!e) continue;
        if (e.gridX === player.gridX && e.gridY === player.gridY) {
            const points = e.isRare ? 500 : 100;
            const rareStatus = e.isRare;
            const gx = e.gridX; const gy = e.gridY;
            enemies.splice(i, 1);
            player.combo++;
            player.comboTimer = 1.4;
            player.maxCombo = Math.max(player.maxCombo, player.combo);
            player.score += points;
            scoreEl.innerText = player.score;
            shake = rareStatus ? 30 : 12;
            createExplosion(gx, gy, rareStatus ? '#fbbf24' : '#ef4444', rareStatus ? 40 : 20);
            playSound('hit', 150 + player.combo * 8);

            // 20コンボごとに、(コンボ数 / 20) の整数部分と同じ数だけクイズを追加
            if (player.combo > 0 && player.combo % 20 === 0) {
                quizPendingCount += Math.floor(player.combo / 20);
                if (!isPaused) {
                    enemies = []; // クイズ開始時に敵を消去
                    startNextQuiz();
                }
            }
        }
    }
}

function startNextQuiz() {
    if (quizPendingCount <= 0) {
        finalizeQuizzes();
        return;
    }

    isPaused = true;
    shake = 50;
    
    const available = MASTER_RADICAL_LIST.filter(r => !usedQuizzes.includes(r.q));
    const quiz = available.length > 0 
        ? available[Math.floor(Math.random() * available.length)]
        : MASTER_RADICAL_LIST[Math.floor(Math.random() * MASTER_RADICAL_LIST.length)];
    
    usedQuizzes.push(quiz.q);
    
    const overlay = document.getElementById('quiz-overlay');
    document.getElementById('quiz-pending-count').innerText = `残り問題数: ${quizPendingCount}`;
    document.getElementById('quiz-progress').innerText = `発見した部首: ${Math.min(usedQuizzes.length, 50)} / 50`;
    document.getElementById('quiz-question').innerText = quiz.q;
    
    const optsBox = document.getElementById('quiz-options');
    optsBox.innerHTML = '';
    [...quiz.opts].sort(() => Math.random() - 0.5).forEach(opt => {
        const btn = document.createElement('div');
        btn.className = 'quiz-option';
        btn.innerText = opt;
        btn.onclick = () => {
            if (opt === quiz.a) {
                const bonus = 2000 * Math.min(usedQuizzes.length, 10); 
                player.score += bonus;
                scoreEl.innerText = player.score;
                playSound('correct');
                showPop(`正解！コンボ継続！ +${bonus}`, '#facc15');
                createExplosion(CELL_COUNT/2, CELL_COUNT/2, '#ffffff', 80, true);
            } else {
                playSound('wrong');
                showPop(`ミス！コンボリセット`, '#ef4444');
                resetComboOnResume = true; // 不正解ならリセットフラグを立てる
            }
            
            quizPendingCount--;
            if (quizPendingCount > 0) {
                startNextQuiz();
            } else {
                finalizeQuizzes();
            }
        };
        optsBox.appendChild(btn);
    });
    
    overlay.classList.remove('hidden');
}

function finalizeQuizzes() {
    const overlay = document.getElementById('quiz-overlay');
    overlay.classList.add('hidden');
    isPaused = false;
    
    if (resetComboOnResume) {
        player.combo = 0;
        comboContainer.classList.add('hidden');
        resetComboOnResume = false;
    } else {
        // 正解時はコンボタイマーを少し回復させて復帰しやすくする
        player.comboTimer = 1.4;
    }
}

function createExplosion(gx, gy, color, count, center = false) {
    const sx = center ? width/2 : (gx + 0.5) * cellSize;
    const sy = center ? height/2 : (gy + 0.5) * cellSize;
    for (let i = 0; i < count; i++) {
        const ang = Math.random() * Math.PI * 2;
        const spd = Math.random() * 25 + 5;
        particles.push({ x: sx, y: sy, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, life: 1.0, color, size: Math.random()*6 + 2 });
    }
}

function showPop(text, color) {
    const div = document.createElement('div');
    div.className = 'score-pop';
    div.style.color = color; div.style.left = '50%'; div.style.top = '40%'; div.style.textShadow = `0 0 20px ${color}`;
    div.innerText = text;
    document.getElementById('game-container').appendChild(div);
    setTimeout(() => div.remove(), 1200);
}

function update(dt) {
    if (isGameOver || !gameStarted || isPaused) return;
    handleInput(dt);
    timeLeft -= dt;
    if (timeLeft <= 0) { timeLeft = 0; isGameOver = true; showResults(); }
    timerEl.innerText = timeLeft.toFixed(1);

    const ease = 18 * dt;
    player.vX += (player.gridX - player.vX) * ease;
    player.vY += (player.gridY - player.vY) * ease;

    if (player.combo > 0) {
        player.comboTimer -= dt;
        comboContainer.classList.remove('hidden');
        comboEl.innerText = player.combo.toString().padStart(2, '0');
        comboBar.style.width = (player.comboTimer / 1.4 * 100) + "%";
        if (player.comboTimer <= 0) {
            if (quizPendingCount > 0) startNextQuiz();
            else {
                player.combo = 0;
                comboContainer.classList.add('hidden');
            }
        }
    }

    spawnTimer += dt;
    const rate = gameMode === 'hard' ? 0.05 : 0.25;
    if (spawnTimer > rate) { spawnEnemy(); spawnTimer = 0; }

    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i]; if (!e) continue;
        e.vX += (e.gridX - e.vX) * (ease * 0.4);
        e.vY += (e.gridY - e.vY) * (ease * 0.4);
        e.moveTimer += dt;
        const mRate = gameMode === 'hard' ? 0.3 : 0.7;
        if (e.moveTimer > mRate) {
            e.moveTimer = 0;
            const dirs = [[0,1],[0,-1],[1,0],[-1,0]]; const d = dirs[Math.floor(Math.random()*4)];
            e.gridX = Math.max(0, Math.min(CELL_COUNT-1, e.gridX + d[0]));
            e.gridY = Math.max(0, Math.min(CELL_COUNT-1, e.gridY + d[1]));
            if (e.gridX === player.gridX && e.gridY === player.gridY) checkHit();
        }
    }
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= dt * 1.5;
        if (p.life <= 0) particles.splice(i, 1);
    }
    if (shake > 0) shake *= 0.85;
}

function draw() {
    ctx.clearRect(0, 0, width, height);
    ctx.save();
    if (shake > 1) ctx.translate((Math.random()-0.5)*shake, (Math.random()-0.5)*shake);
    ctx.strokeStyle = 'rgba(59, 130, 246, 0.1)'; ctx.lineWidth = 1;
    for (let i = 0; i <= CELL_COUNT; i++) {
        ctx.beginPath(); ctx.moveTo(i*cellSize, 0); ctx.lineTo(i*cellSize, height); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, i*cellSize); ctx.lineTo(width, i*cellSize); ctx.stroke();
    }
    particles.forEach(p => {
        ctx.globalAlpha = p.life; ctx.shadowBlur = 10; ctx.shadowColor = p.color; ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
    });
    ctx.globalAlpha = 1; ctx.shadowBlur = 0;
    enemies.forEach(e => {
        if (!e) return;
        const x = (e.vX + 0.5) * cellSize, y = (e.vY + 0.5) * cellSize;
        const r = cellSize * 0.38 + Math.sin(Date.now()*0.01 + e.phase)*5;
        ctx.save(); ctx.translate(x, y); ctx.rotate(Date.now() * 0.005 + e.phase);
        ctx.shadowBlur = 15; ctx.shadowColor = e.isRare ? '#fbbf24' : '#ef4444'; ctx.fillStyle = e.isRare ? '#fbbf24' : '#ef4444';
        ctx.beginPath();
        for (let i = 0; i < 4; i++) {
            const ang = i * Math.PI / 2; ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
            ctx.lineTo(Math.cos(ang + Math.PI/4)*r*0.4, Math.sin(ang + Math.PI/4)*r*0.4);
        }
        ctx.closePath(); ctx.fill(); ctx.restore();
    });
    const px = (player.vX + 0.5) * cellSize, py = (player.vY + 0.5) * cellSize, ps = cellSize * 0.7;
    const grad = ctx.createRadialGradient(px, py + ps*0.3, 0, px, py + ps*0.6, ps*0.5);
    grad.addColorStop(0, '#60a5fa'); grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(px, py + ps*0.3, ps*0.5 + Math.random()*5, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(px, py); ctx.rotate(player.tilt);
    ctx.shadowBlur = 20 + Math.min(player.combo, 40); ctx.shadowColor = '#3b82f6';
    ctx.fillStyle = '#1e293b'; ctx.strokeStyle = '#60a5fa'; ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(0, -ps*0.5); ctx.lineTo(ps*0.4, ps*0.3); ctx.lineTo(0, ps*0.1); ctx.lineTo(-ps*0.4, ps*0.3); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(0, -ps*0.1, ps*0.12, 0, Math.PI*2); ctx.fill();
    ctx.restore(); ctx.restore();
}

function showResults() {
    document.getElementById('ui-overlay').classList.add('hidden');
    document.getElementById('result-screen').classList.remove('hidden');
    document.getElementById('final-score').innerText = player.score.toLocaleString();
    document.getElementById('final-stats').innerText = `最高コンボ数: ${player.maxCombo} | 解いた部首数: ${usedQuizzes.length}`;
}

function loop(time) {
    const dt = Math.min(0.1, (time - (lastTime || time)) / 1000);
    lastTime = time; update(dt); draw();
    if (!isGameOver) requestAnimationFrame(loop);
}

function startGame(mode) {
    initAudio(); gameMode = mode; gameStarted = true; isGameOver = false; isPaused = false;
    timeLeft = 30.0; player.score = 0; player.combo = 0; player.maxCombo = 0; quizPendingCount = 0;
    player.gridX = 4; player.gridY = 4; player.vX = 4; player.vY = 4;
    enemies = []; particles = []; usedQuizzes = [];
    scoreEl.innerText = "0";
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('result-screen').classList.add('hidden');
    document.getElementById('ui-overlay').classList.remove('hidden');
    lastTime = performance.now(); requestAnimationFrame(loop);
}

window.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
window.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
</script>
</body>
</html>
